name: Deploy to Server

on:
  push:
    branches: ["main"]
  workflow_dispatch: {}

concurrency:
  group: production-deploy
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: Prod   # important si tes secrets sont dans l'env "Prod"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # 0) Pré-vérifs : échoue tôt si un secret critique manque
      - name: Check required secrets
        run: |
          set -e
          test -n "${SERVER_HOST}" || (echo "❌ Missing SERVER_HOST" && exit 1)
          test -n "${SERVER_USER}" || (echo "❌ Missing SERVER_USER" && exit 1)
          test -n "${SERVER_SSH_KEY}" || (echo "❌ Missing SERVER_SSH_KEY" && exit 1)
          echo "✅ Secrets présents"
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_SSH_KEY: ${{ secrets.SERVER_SSH_KEY }}

      # 1) Écrire la clé privée DANS LE WORKSPACE (visible par les actions containerisées)
      - name: Write SSH key file (normalize)
        run: |
          set -e
          mkdir -p ~/.ssh
          # Écrit la clé telle quelle, puis convertit CRLF -> LF
          echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/id_ci
          sed -i 's/\r$//' ~/.ssh/id_ci
          chmod 600 ~/.ssh/id_ci
          # Vérifie que la clé est lisible et valide (ne log pas la clé)
          ssh-keygen -y -f ~/.ssh/id_ci > /dev/null

      # 2) Sanity SSH : vérifie l’accès avant SCP/SSH
      - name: Sanity SSH (whoami@server)
        run: |
          ssh -o StrictHostKeyChecking=accept-new -i ~/.ssh/id_ci \
              ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
              "echo OK && whoami && hostname && test -d ~/.ssh && echo HAS_.ssh || echo NO_.ssh"

      # 2.5) MÉNAGE CIBLE : répertoire propre et possédé par l'utilisateur
      - name: Prepare target dir (own & clean)
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            mkdir -p ~/app_src
            sudo chown -R "$USER":"$USER" ~/app_src || true

            # Backup acme.json si présent
            if [ -f ~/app_src/traefik/acme.json ]; then
              cp ~/app_src/traefik/acme.json /tmp/acme.json.backup
            fi

            # Ménage complet
            rm -rf ~/app_src/* ~/app_src/.[!.]* ~/app_src/..?* || true

            # Restore acme.json si présent
            mkdir -p ~/app_src/traefik
            if [ -f /tmp/acme.json.backup ]; then
              mv /tmp/acme.json.backup ~/app_src/traefik/acme.json
              chmod 600 ~/app_src/traefik/acme.json
            fi

      # 3) Upload du projet vers le serveur (~/app_src)
      #    On n'envoie PAS les fichiers cachés (.git, etc.) pour éviter les conflits de droits
      - name: Upload project to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "./*"           # ← exclut .git et autres dotfiles par défaut
          target: "~/app_src"
          overwrite: true
          timeout: 120s

      # 4) Provision + Déploiement complet
      - name: Provision & Deploy (Docker, .env, compose up)
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -euo pipefail

            echo "[1/6] Vérification / installation Docker + compose"
            if ! command -v docker >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y ca-certificates curl gnupg
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(. /etc/os-release && echo $VERSION_CODENAME) stable" | sudo tee /etc/apt/sources.list.d/docker.list >/dev/null
              sudo apt-get update -y
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            fi

            echo "[2/6] Préparation dossier projet"
            cd ~
            mkdir -p app_src
            cd app_src

            echo "[3/6] Génération du .env côté serveur"
            rm -f .env
            {
              echo "############################################################"
              echo "#                     BASE DE DONNÉES"
              echo "############################################################"
              # URL Prisma (tu gardes la tienne)
              echo "DATABASE_URL=${{ secrets.DATABASE_URL }}"
              echo
              # Vars "fonctionnelles" (utilisées par compose)
              echo "DB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}"
              echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}"
              # Vars MariaDB officielles
              DB_USER="${{ vars.DB_USER }}"
              DB_NAME="${{ vars.DB_NAME }}"
              DB_USER="${DB_USER:-bde_prod}"
              DB_NAME="${DB_NAME:-bde_prod}"
              echo "MARIADB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}"
              echo "MARIADB_PASSWORD=${{ secrets.DB_PASSWORD }}"
              echo "MARIADB_USER=${DB_USER}"
              echo "MARIADB_DATABASE=${DB_NAME}"

              echo "############################################################"
              echo "#             NEXTAUTH (AUTHENTIFICATION)"
              echo "############################################################"
              echo "NEXTAUTH_URL=${{ vars.NEXTAUTH_URL }}"
              echo "NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}"
              # echo "AUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}"  # si Auth.js v5

              echo
              echo "############################################################"
              echo "#                    GOOGLE OAUTH - DEV"
              echo "############################################################"
              echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}"
              echo "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}"

              echo
              echo "############################################################"
              echo "#                       STRIPE - DEV"
              echo "############################################################"
              echo "STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}"
              echo "STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}"
              echo "STRIPE_ADHESION_PRICE_CENTS=${{ vars.STRIPE_ADHESION_PRICE_CENTS }}"

              echo
              echo "############################################################"
              echo "#                        EMAIL / SMTP"
              echo "############################################################"
              echo "SMTP_HOST=${{ vars.SMTP_HOST }}"
              echo "SMTP_PORT=${{ vars.SMTP_PORT }}"
              echo "SMTP_SECURE=${{ vars.SMTP_SECURE }}"
              echo "SMTP_USER=${{ vars.SMTP_USER }}"
              echo "SMTP_PASS=${{ secrets.SMTP_PASS }}"
              echo "SMTP_FROM=${{ vars.SMTP_FROM }}"

              echo
              echo "############################################################"
              echo "#                   NEXT PUBLIC (EXPOSÉ CLIENT)"
              echo "############################################################"
              echo "NEXT_PUBLIC_APP_URL=${{ vars.NEXT_PUBLIC_APP_URL }}"

              echo
              echo "############################################################"
              echo "#               INTEGRATIONS EXTERNES / RÉSEAUX"
              echo "############################################################"
              echo "INSTAGRAM_GRAPH_TOKEN=${{ secrets.INSTAGRAM_GRAPH_TOKEN }}"

              echo
              echo "############################################################"
              echo "#                 (OPTIONNEL) INFRA / TRAEFIK"
              echo "############################################################"
              echo "DOMAIN=${{ vars.DOMAIN }}"
              echo "TRAEFIK_ACME_EMAIL=${{ vars.TRAEFIK_ACME_EMAIL }}"
              echo
            } >> .env

            echo "[3b/6] Préparer le store ACME de Traefik"
            mkdir -p traefik
            # Si par erreur c'est un dossier, on le remplace par un fichier
            if [ -d traefik/acme.json ]; then rm -rf traefik/acme.json; fi
            # Créer le fichier s'il n'existe pas + bon chmod
            if [ ! -f traefik/acme.json ]; then
              install -m 600 /dev/null traefik/acme.json || { touch traefik/acme.json && chmod 600 traefik/acme.json; }
            else
              chmod 600 traefik/acme.json
            fi

            echo "[4/6] Démarrage Traefik + DB"
            sudo docker compose down || true
            sudo docker compose up -d traefik db

            echo "[4b/6] Attente santé MariaDB"
            for i in {1..60}; do
              state=$(sudo docker inspect --format='{{json .State.Health.Status}}' mariadb 2>/dev/null || echo "null")
              echo "Health mariadb: $state"
              [ "$state" = "\"healthy\"" ] && break
              sleep 2
            done

            echo "[4c/6] Prisma migrate deploy (idempotent)"
            # ❗ ÉCHOUER si la migration échoue
            sudo docker compose run --rm web npx prisma migrate deploy

            echo "[4d/6] Démarrage de l'app web (build + run)"
            sudo docker compose up -d --build web

            echo "[5/6] (Option) Migrations Prisma si prisma/ existe"
            if [ -d "prisma" ]; then
              # (optionnel) attendre que la DB soit healthy
              for i in {1..30}; do
                state=$(sudo docker inspect --format='{{json .State.Health.Status}}' mariadb 2>/dev/null || echo "null")
                if [ "$state" = "\"healthy\"" ]; then echo "MariaDB healthy"; break; fi
                sleep 2
              done
              sudo docker compose run --rm web npx prisma migrate deploy || true
              sudo docker compose restart web || true
            fi

            echo "[6/6] Vérification conteneurs"
            sudo docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
            echo "Déploiement terminé 🎉"
